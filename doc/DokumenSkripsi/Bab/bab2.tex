\chapter{Dasar Teori}
\section{OpenStreetMap}
OpenStreetMap (OSM) adalah portal peta terbuka yang menyediakan data dalam
bentuk peta atau XML \cite{osm}. OSM menyediakan peta dijital dan dapat diedit dari seluruh dunia, juga memungkinkan pengguna untuk mengakses gambar peta yang terdapat pada
situs \url{www.openstreetmap.org} secara gratis. OSM terbentuk dan mendapatkan
datanya dari berbagai sukarelawan yang bersedia untuk berkontribusi, misalnya para pengguna OSM yang menggunakan aplikasi untuk 
mengedit peta dan mengunggah data yang telah diedit ke situs OSM. Selain itu, OSM menyediakan 
beberapa aplikasi bagi para pengguna untuk mengedit peta, seperti iD online editor dan JOSM. 
Untuk mendapatkan gambar peta ataupun data peta dalam bentuk lain, pengguna dapat menggunakan 
fitur export pada situs OSM. Fitur export pada situs OSM dapat
dilihat pada Gambar \ref{fig:export_osm}.
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{Gambar/export_osm}
\caption[Ekspor data pada situs OpenStreetMap]{Ekspor data pada situs
OpenStreetMap}
\label{fig:export_osm}
\end{figure}

Berikut ini adalah beberapa data yang dapat diambil menggunakan fitur export
\cite{osm}:
\begin{enumerate}
\item OpenStreetMap XML Data

OSM XML data dapat diperoleh dengan cara menggunakan tombol Export di bagian atas untuk 
membuka sidebar. Tombol Export mengarahkan langsung browser kepada OpenStreetMap API yang 
menyediakan data mentah OSM dalam bentuk XML.

\item Mapnik \textit{Image} 

Memungkinkan ekspor data OSM dalam bentuk PNG, JPEG, SVG, PDF dan peta PostScript.

\item \textit{Embeddable} HTML

Fitur ini memungkinkan pengguna untuk mendapatkan kode HTML yang dapat disalin dan digunakan pada halaman web lain. Kode HTML tersebut akan menyisipkan peta dalam sebuah iframe lengkap dengan javascript.
\end{enumerate}

\section{XML}
XML adalah singkatan dari eXtensible Markup Language, XML adalah bahasa markup 
yang dikembangkan oleh W3C (World Wide Web Consortium)
\cite{Benoit:2000}. Berikut ini adalah contoh dokumen XML:
\lstset{basicstyle=\normalsize}
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
  <catalog>
   <book id="bk101">
      <author>Gambardella, Matthew</author>
      <title>XML Developer's Guide</title>
      <genre>Computer</genre>
      <price>44.95</price>
      <publish_date>2000-10-01</publish_date>
      <description>An in-depth look at creating applications 
      with XML.</description>
   </book>
   <book id="bk102">
      <author>Ralls, Kim</author>
      <title>Midnight Rain</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2000-12-16</publish_date>
      <description>A former architect battles corporate zombies, 
      an evil sorceress, and her own childhood to become queen 
      of the world.</description>
   </book>
  <catalog>
\end{lstlisting}
Contoh di atas memberikan informasi mengenai katalog buku yang disimpan pada
dokumen XML. Pada awal dokumen tertera versi XML dan \textit{encoding} yang
digunakan. Setelah itu, terdapat tag catalog yang memiliki \textit{child} yaitu
tag buku beserta informasinya. Terdapat informasi id buku yang tertera pada atribut tag buku,
seperti <book id="bk101"> dan juga informasi lain seperti judul buku, penulis,
genre, harga, tanggal terbit, dan deskripsi.

XML dikembangkan terutama 
untuk mengatasi keterbatasan pada HTML (Hypertext Markup Language). HTML adalah 
salah satu bahasa markup yang paling populer dan terus dikembangkan, banyak tag baru 
yang diperkenalkan. Pada versi pertama, HTML memiliki satu lusin tag dan pada
HTML pada versi 4.0 sudah hampir mencapai seratus tag. Namun, pada aplikasi
seperti \textit{electronic commerce} dibutuhkan tag lebih untuk produk, harga, nama,
alamat, dan banyak lagi atau situs \textit{streaming} memerlukan tag lebih untuk
mengontrol gambar dan suara.
\lstset{language=XML}

HTML telah berkembang menjadi bahasa yang cukup kompleks, W3C memperkirakan
penggunaan komputer akan terus berkurang dan penggunaan gadget seperti smartphone 
akan bertambah. Mesin tersebut tidak sekuat PC dan tidak bisa memproses bahasa yang 
kompleks seperti HTML . Meskipun HTML adalah bahasa yang populer dan cukup sukses, HTML 
memiliki beberapa kelemahan utama dan XML dikembangkan untuk mengatasi kelemahan tersebut. 
XML adalah bahasa yang digunakan untuk menggambarkan dan memanipulasi dokumen
terstruktur. Perubahan utama pada XML adalah tidak adanya tag yang ditetapkan pada XML. 
Karena tidak ada tag yang ditetapkan, penulis dapat membuat tag yang dibutuhkan. 
Beberapa ketentuan pada XML dapat dilihat pada uraian berikut:
\begin{enumerate}
\item Tag pada XML \\
Setiap elemen pada XML terdiri dari nama dan nilai, selain itu harus memiliki
tag pembuka dan tag penutup. Contoh: 
\begin{verbatim}
<tel> 513-555-7098 </ tel>
\end{verbatim}
Elemen untuk menyimpan nomor telepon memiliki nama tag tel, ditulis dengan <tel>
dan ditutup dengan </tel>.

\item Nama pada XML \\
Pemberian nama pada XML harus dimulai dengan huruf atau underscore (\_) dan
sisanya diikuti huruf, angka, atau titik. Spasi tidak diperbolehkan pada
pemberian nama.

\item Atribut \\
Atribut memungkinkan untuk menyisipkan informasi tambahan, atribut juga memiliki
nama dan nilai. Contoh:
\begin{verbatim}
<tel preferred="true">513-555-8889</tel>
<tel>513-555-7098</tel>
\end{verbatim}
Elemen tel dapat memiliki atribut \textit{preferred}, memberikan informasi nomor
telepon yang lebih sering digunakan.

\item Elemen Kosong \\
Elemen yang tidak memiliki nilai atau isi disebut sebagai elemen kosong. Elemen
kosong biasanya memiliki atribut. Contoh:
\begin{verbatim}
<email href="mailto:jdoe@emailaholic.com"></email>
\end{verbatim}
Elemen email tidak memiliki nilai atau isi.

\item \textit{Nesting of Elements} \\
Sebuah elemen dapat memiliki elemen lain di dalamnya. Elemen yang berada di
dalam elemen lain disebut \textit{child}, sedangkan elemen yang memiliki elemen
lain disebut \textit{parent}. Contoh
\begin{verbatim}
<name>
  <fname>Jack</fname>
  <lname>Smith</lname>
</name>
\end{verbatim}
Pada contoh berikut elemen name memiliki dua
\textit{child} yaitu fname dan lname dan elemen name merupakan \textit{parent}
dari kedua elemen tersebut.

\item \textit{Root} \\
\textit{Root} merupakan elemen level tertinggi, pada dokumen XML harus
ada satu elemen pada level tertinggi. Dengan kata lain, elemen lain harus menjadi
\textit{child} dari \textit{root}.

\item Deklarasi XML \\
Deklarasi XML dituliskan pada baris pertama dokumen. Pada deklarasi tersebut
juga dituliskan versi XML yang digunakan. Contoh:
\begin{verbatim}
<?xml version="1.0"?>
\end{verbatim}
\end{enumerate}

\subsection{OSMXML} \label{ssec:osmxml}
OpenStreetMap XML atau biasa disingkat dengan OSMXML merupakan dokumen XML yang
berisi data-data peta OSM. Pada dasarnya, OSMXML berisi data primitif
(node, way, dan relation) yang merupakan arsitektur dari model OSM
\cite{osm}.
Berikut ini adalah contoh dokumen OSMXML:
\lstset{
  language=XML,
  morekeywords={osm,bounds,node,way,relation,tag,nd,member}
}
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<osm version="0.6" generator="CGImap 0.0.2">
 <bounds minlat="54.0889580" minlon="12.2487570" maxlat="54.0913900" maxlon="12.2524800"/>
 <node id="298884269" lat="54.0901746" lon="12.2482632" user="SvenHRO" uid="46882" visible="true" version="1" changeset="676636" timestamp="2008-09-21T21:37:45Z"/>
 <node id="261728686" lat="54.0906309" lon="12.2441924" user="PikoWinter" uid="36744" visible="true" version="1" changeset="323878" timestamp="2008-05-03T13:39:23Z"/>
 <node id="1831881213" version="1" changeset="12370172" lat="54.0900666" lon="12.2539381" user="lafkor" uid="75625" visible="true" timestamp="2012-07-20T09:43:19Z">
  <tag k="name" v="Neu Broderstorf"/>
  <tag k="traffic_sign" v="city_limit"/>
 </node>
 ...
 <node id="298884272" lat="54.0901447" lon="12.2516513" user="SvenHRO" uid="46882" visible="true" version="1" changeset="676636" timestamp="2008-09-21T21:37:45Z"/>
 <way id="26659127" user="Masch" uid="55988" visible="true" version="5" changeset="4142606" timestamp="2010-03-16T11:47:08Z">
  <nd ref="292403538"/>
  <nd ref="298884289"/>
  ...
  <nd ref="261728686"/>
  <tag k="highway" v="unclassified"/>
  <tag k="name" v="Pastower Straße"/>
  <tag k="oneway" v="yes"/>
 </way>
 <relation id="56688" user="kmvar" uid="56190" visible="true" version="28" changeset="6947637" timestamp="2011-01-12T14:23:49Z">
  <member type="node" ref="294942404" role=""/>
  ...
  <member type="node" ref="364933006" role=""/>
  <member type="way" ref="4579143" role=""/>
  ...
  <member type="node" ref="249673494" role=""/>
  <tag k="name" v="Küstenbus Linie 123"/>
  <tag k="network" v="VVW"/>
  <tag k="operator" v="Regionalverkehr Küste"/>
  <tag k="ref" v="123"/>
  <tag k="route" v="bus"/>
  <tag k="type" v="route"/>
 </relation>
 ...
</osm>
\end{lstlisting}
Struktur OSMXML:
\begin{itemize}
\item Dokumen OSMXML diawali dengan tag xml yang menjelaskan versi xml dan
encoding yang digunakan, pada contoh di atas digunakan xml versi 1.0 dan
encoding UTF-8.

\item Elemen osm memberikan informasi mengenai versi API dan generator yang
digunakan. Generator adalah alat untuk membuat dokumen OSMXML pada saat fitur
export digunakan. 

\item Elemen bound memberikan informasi mengenai cakupan area pada dokumen
OSMXML tersebut. Dilengkapi dengan atribut koordinat yaitu latitude dan longitude.
Data primitif pada OSM dibagi menjadi 3 bagian, yaitu node, way, dan relation.
\begin{enumerate}
\item Elemen Node merupakan informasi titik pada sebuah peta. Node memiliki
beberapa atribut yaitu:
\begin{itemize}
\item id \\
Merupakan id dari node tersebut.

\item user \\ 
Merupakan user yang melakukan editing pada node.

\item uid \\
Id dari user.

\item lat \\
berisi informasi koordinat pada garis lintang.

\item lon \\
berisi informasi koordinat pada garis bujur.

\item timestamp \\
Berisi informasi waktu saat node tersebut diperbaharui.
\end{itemize}
Node juga memiliki elemen tag sebagai \textit{child} yang memberikan informasi
tambahan pada node tersebut, contoh:
\begin{verbatim}
<tag k="name" v="Neu Broderstorf"/>
\end{verbatim}
nama dari node tersebut adalah Neu Broderstorf.

\item Elemen Way merupakan informasi garis yang dapat diartikan sebagai jalan
ataupun elemen lain seperti rel kereta pada peta OSM. Way menyimpan informasi
node-node terurut yang dilalui oleh garis dan juga sama seperti node dilengkapi
atribut seperti id, uid, user, changeset, timestamp. Elemen way memiliki \textit{child}
elemen nd, contoh:
\begin{verbatim}
<nd ref="292403538"/>
\end{verbatim}
atribut ref pada elemen nd mengacu pada node yang memiliki id 292403538, dan
elemen tag yang memberikan informasi tambahan pada elemen way. Selain itu,
elemen way memiliki informasi lain yang disimpan pada elemen tag, elemen tag
merupakan \textit{child} dari elemen way dan menyimpan informasi jenis jalan
yaitu \textit{key highway} dan \textit{key oneway} yang memberikan informasi
arah jalan, contoh:
\begin{verbatim}
<tag k="highway" v="unclassified"/>
<tag k="oneway" v="yes"/>
\end{verbatim}
\textit{Key oneway} memiliki 4 jenis \textit{value}. Informasi arah jalan
mengikuti node-node yang telah terurut. Berikut ini adalah
penjelasan dari keempat \textit{value} tersebut:
\begin{itemize}
  \item oneway=yes \\
  Menunjukkan jalan satu arah
  
  \item oneway=no \\
  Menujukkan jalan dua arah
  
  \item oneway=-1 \\
  Menunjukkan jalan satu arah dan berlawanan
  
  \item oneway=reversible \\
  Menunjukkan jalan satu arah dan dapat berubah arah menjadi berlawanan. Contoh,
  pengalihan jalan untuk mengatasi kemacetan.
\end{itemize}

\item Elemen relation menyimpan informasi node-node dan way yang bersinggungan.
Elemen relation dapat menggambarkan suatu area seperti lapangan, taman
bermain.
\begin{lstlisting}
<relation id="56688" user="kmvar" uid="56190" visible="true" version="28" changeset="6947637" timestamp="2011-01-12T14:23:49Z">
  <member type="node" ref="294942404" role=""/>
  ...
  <member type="node" ref="364933006" role=""/>
  <member type="way" ref="4579143" role=""/>
  ...
  <member type="node" ref="249673494" role=""/>
  <tag k="name" v="Küstenbus Linie 123"/>
  <tag k="network" v="VVW"/>
  <tag k="operator" v="Regionalverkehr Küste"/>
  <tag k="ref" v="123"/>
  <tag k="route" v="bus"/>
  <tag k="type" v="route"/>
 </relation>
\end{lstlisting}
Pada contoh di atas menggambarkan rute bus.
\end{enumerate}
\end{itemize}

\section{Javascript}
Javascript adalah bahasa pemrograman web yang mulai dikembangkan di perusahaan
yang bernama Netscape. Javascript memiliki lisensi dari Sun Microsystems yang sekarang sudah berganti nama 
menjadi Oracle. Saat ini, mayoritas situs web sudah menggunakan javascript.
Berikut ini adalah contoh penggunaan javascript pada dokumen HTML:
\lstset{
  language=HTML
}
\begin{lstlisting}
<!DOCTYPE html>
<html>
<head>
<script>
function myFunction() {
    document.getElementById("demo").innerHTML = "Paragraph changed.";
}
</script>
</head>
<body>
<h1>JavaScript in Head</h1>
<p id="demo">A Paragraph.</p>
<button type="button" onclick="myFunction()">Try it</button>
</body>
</html> 
\end{lstlisting}
Pada contoh di atas terdapat fungsi yang ditulis menggunakan javascript,
fungsi tersebut akan mengubah string ``A Paragraph'' pada tag <p> menjadi
``Paragraph changed'' jika \textit{button} atau tombol ``Try it'' di klik.

Seluruh browser yang terdapat pada komputer, konsol game, tablet, dan smartphone
sudah mendukung Javascript. Javascript adalah bagian yang cukup penting pada
sebuah halaman web, jika HTML berfungsi untuk menentukan isi dari halaman dan 
CSS untuk menentukan tampilan pada halaman, javascript 
berfungsi untuk menentukan ``behavior'' dari halaman web tersebut
\cite{Flanagan:2011}.
Berikut ini adalah uraian dari struktur javascript dan beberapa contoh sintaks:
\begin{enumerate}
\item Struktur

\begin{itemize}
\item \textit{Character Set} \\
Javascript ditulis menggunakan karakter Unicode. Unicode adalah superset ASCII dan Latin-1 yang mendukung 
hampir seluruh bahasa di dunia.

\item \textit{Comments} \\
Javascript mendukung 2 jenis komentar yaitu komentar yang diletakkan setelah garis miring ganda // dan komentar yang 
diletakkan antara karakter /* dan */.
\begin{verbatim}
// This is a single-line comment.
/* This is also a comment */ // and here is another comment.
/*
* This is yet another comment.
* It has multiple lines.
*/
\end{verbatim}

\item Literal \\
Literal adalah notasi untuk merepresentasikan nilai 
dan nilai yang dituliskan akan muncul secara langsung dalam program. Literal
dapat berupa karakter, bilangan bulat, bilangan real, boolean. Berikut
ini adalah contoh literal:
\begin{verbatim}
12 // The number twelve
1.2 // The number one point two
"hello world" // A string of text
'Hi' // Another string
true // A Boolean value
false // The other Boolean value
/javascript/gi // A "regular expression" literal (for pattern matching)
null // Absence of an object 
\end{verbatim}

\item \textit{Identifier} \\
\textit{Identifier} pada javascript hanyalah nama yang digunakan untuk memberi
nama pada variabel atau fungsi. Digit tidak diperbolehkan sebagai karakter
pertama pada \textit{identifier}.

\item \textit{Reserved words} \\
\textit{Reserved words} adalah kata-kata yang tidak dapat digunakan sebagai
identifier, karena digunakan oleh javascript sebagai keyword. Beberapa contoh keyword seperti break, delete, if, 
null, true, false, try, dan lain-lain.

\item \textit{Optional Semicolons} \\
Seperti banyak bahasa pemrograman lain, javascript menggunakan titik koma (;) untuk memisahkan perintah 
yang ditulis. Hal ini penting untuk membuat kode program menjadi jelas mengenai awal dan akhir. Pada 
javascript, titik koma dapat dihilangkan jika perintah ditulis pada baris yang berbeda, berikut adalah 
contoh penggunaan titik koma pada javascript:
\begin{verbatim}
a = 3;
b = 4;
\end{verbatim}
titik koma pertama dapat dihilangkan, namun jika ditulis pada baris yang sama, titik koma tetap diperlukan
\begin{verbatim}
a = 3; b = 4;
\end{verbatim}
\end{itemize}

\item Sintaks
\begin{itemize}
\item Deklarasi Variabel \\
Pembuatan variabel pada javascript menggunakan keyword var. Contoh deklarasi atau pembuatan variabel pada javascript:
\begin{verbatim}
var i;
var i, sum;
var message = "hello";
var i = 0, j = 0, k = 0;
\end{verbatim}

\item Fungsi \\
Fungsi adalah blok kode program yang hanya dituliskan sekali, tetapi dapat
dipanggil atau dijalankan berulang kali. Pada javascript, fungsi dapat dibuat menggunakan keyword function. 
Sebuah fungsi harus memiliki nama, sepasang tanda kurung untuk parameter, dan sepasang kurung kurawal. 
Berikut ini adalah beberapa contoh fungsi:
\begin{verbatim}
// Print the name and value of each property of o. Return undefined.
function printprops(o) {
  for(var p in o)
    console.log(p + ": " + o[p] + "\n");
}
\end{verbatim}
\begin{verbatim}
// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
function distance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx*dx + dy*dy);
}
\end{verbatim}

\item Kelas \\
Pada javascript, kelas adalah objek. Cara untuk membuat kelas pada javascript
adalah dengan membuat fungsi dan membuat objek dari fungsi tersebut menggunakan
\textit{keyword} ``new''. Berikut ini adalah contoh pembuatan kelas pada
javascript:
\begin{verbatim}
function Range(from, to) {
// Store the start and end points (state) of this new range object.
// These are noninherited properties that are unique to this object.
this.from = from;
this.to = to;
}

// Contoh pembuatan objek
var r = new Range(1,3);
\end{verbatim}
\end{itemize}
\end{enumerate}

\subsection{XMLHttpRequest}
XMLHttpRequest adalah salah satu objek pada javascript yang dapat digunakan
untuk mendapatkan \textit{file} XML dari \textit{server} secara \textit{asynchronous}
atau \textit{synchronous} \cite{Edmond:2006}. \textit{Asynchronous} berarti
bahwa pertukaran data dilakukan tanpa harus memuat ulang seluruh halaman \textit{web}, sedangkan 
pertukaran data \textit{synchronous} harus memuat ulang seluruh halaman
\textit{web}. Berikut ini adalah contoh penggunaan XMLHttpRequest:
\begin{verbatim}
var objXMLHTTP = new XMLHttpRequest();

objXMLHTTP.open('GET', 'books.xml', false);
objXMLHTTP.send();

var objXML = objXMLHTTP.responseXML;
\end{verbatim}
Langkah pertama adalah dengan membuat objek XMLHttpRequest. Selanjutnya, dengan
memanggil fungsi open(``method'', ``url'', asynchronous). Parameter
\textit{method} menentukan metode yang digunakan, contoh ``GET'' untuk menerima
data dan ``POST'' untuk mengirim data, parameter url adalah alamat
\textit{file}, dan parameter boolean ``false'' menunjukkan bahwa permintaan tersebut
dilakukan secara \textit{synchronous}. Langkah terakhir adalah mendapatkan
respon dari \textit{server}. Berikut ini penjelasan dari setiap \textit{method}
yang digunakan:
\begin{enumerate}
  \item open("method","url", asynchronous,"username","password")\\
  Melakukan inisialisasi permintaan\\
	Parameter:
  \begin{itemize}
    \item \textit{method}\\
    Method pada HTTP yang digunakan seperti ``GET'' dan ``POST''.
    
    \item \textit{url}\\
    Alamat url tujuan 
    
    \item \textit{asynchronous}\\
    boolean Opsional, secara default bernilai \textit{true}. \textit{True}
    menyatakan bahwa operasi yang dijalankan secara \textit{asynchronous}. Nilai
    \textit{false} menyatakan sebaliknya.
    
    \item \textit{username}\\
    Opsional, berisikan \textit{username} yang digunakan untuk keperluan
    otentikasi.
    Secara default, berisi string kosong.
    
    \item \textit{password}\\
    Opsional, berisikan \textit{password} yang digunakan untuk keperluan
    otentikasi. Secara default, berisi string kosong.
  \end{itemize}
  
  \item send(content)\\
  Mengirimkan permintaan\\
  Parameter:
  \begin{itemize}
    \item \textit{content}\\
    Opsional, \textit{content} dapat berisi string atau data lainnya seperti
    Array, dokumen, dan lain-lain.
  \end{itemize}
  
  \item responseXML\\
  Respon dari permintaan\\
  Return:\\
  DOM Object
\end{enumerate}

\subsection{XML DOM}
DOM adalah singkatan dari \textit{Document Object Model}, XML DOM adalah API
umum untuk menangani dokumen XML \cite{Edmond:2006}. API adalah singkatan dari
\textit{Application Programming Interface} merupakan fungsi atau perintah yang dapat digunakan untuk
menangani masalah pemrograman tertentu. XML DOM menyediakan fungsi standar
untuk mengakses, memodifikasi, dan menciptakan berbagai bagian dari sebuah dokumen XML.
Contoh:
\begin{verbatim}
var myNodeset = objXML.getElementsByTagName('plant');
var name = myNodeset[0].getAttribute('name');
\end{verbatim}
Pemanggilan fungsi getElementsByTagName('plant') akan mengembalikan satu set
node yang memiliki nama tag 'plant'. Contoh lain, pemanggilan fungsi
getAttribute() akan mengembalikan nilai atribut. Berikut ini penjelasan dari 
setiap \textit{method} yang digunakan:
\begin{enumerate}
  \item getElementsByTagName('tagName')\\
  Mengembalikan elemen-elemen yang memiliki kesesuaian nama.\\
  Parameter:
  \begin{itemize}
    \item tagName\\
    String yang menentukan nama elemen yang dicari.
  \end{itemize}
  Return:\\
  objek berisi elemen yang memiliki nama sesuai dengan yang dicari.
  
  \item getAttribute('name')\\
  Mengembalikan nilai atribut\\
  Parameter:
  \begin{itemize}
    \item name\\
    String yang menentukan nama atribut yang dicari.
  \end{itemize}
  Return:\\
  Mengembalikan string jika atribut memiliki nilai, jika tidak mengembalikan
  \textit{null}.
\end{enumerate}


\subsection{Google Maps Javascript API}
Google Maps Javascript API memungkinkan untuk sebuah halaman web menampilkan
peta dunia yang datanya didapat dari server google \cite{gmap}. Google
menyediakan fungsi atau perintah untuk menampilkan dan menyesuaikan peta sesuai dengan
kebutuhan. 
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\subsubsection{Elemen Dasar Google Maps}
Google Maps Javascript API menyediakan fungsi dan kelas untuk memuat sebuah peta
pada halaman html. Berikut ini adalah contoh halaman web yang menampilkan peta
di lokasi Sydney, Australia:
\lstset{
  language=HTML
}
\begin{lstlisting}
<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
      html, body, #map-canvas { height: 100%; margin: 0; padding: 0;}
    </style>
    <script type="text/javascript"
      src="https://maps.googleapis.com/maps/api/js?key=API_KEY">
    </script>
    <script type="text/javascript">
      function initialize() {
        var mapOptions = {
          center: { lat: -34.397, lng: 150.644},
          zoom: 8
        };
        var map = new google.maps.Map(document.getElementById('map-canvas'),
            mapOptions);
      }
      google.maps.event.addDomListener(window, 'load', initialize);
    </script>
  </head>
  <body>
<div id="map-canvas"></div>
  </body>
</html>
\end{lstlisting}
\begin{itemize}
\item Declaring \\
Google menyarankan untuk membuat deklarasi tipe dokumen pada awal dokumen yaitu
dengan menulis <!DOCTYPE html>. Setelah itu diperlukan CSS yang bekerja untuk
mengatur tampilan peta pada halaman web.
\begin{verbatim}
<style type="text/css">
  html { height: 100% }
  body { height: 100%; margin: 0; padding: 0 }
  #map-canvas { height: 100% }
</style>
\end{verbatim}
Kode CSS pada contoh menunjukkan tag yang memiliki id map-canvas akan memiliki
tinggi 100\% pada saat ditampilkan dan juga menunjukkan persentase yang sama
pada <html> dan <body>.

\item Loading Google Maps API\\
Untuk dapat menampilkan peta diperlukan juga melakukan \textit{load} javascript.
URL yang terdapat pada tag script adalah lokasi file javascript yang akan memuat
seluruh simbol dan definisi yang dibutuhkan untuk menggunakan Google Maps API
ini. Paramater key berisi API key yang dimiliki oleh pengguna.
\begin{verbatim}
<html>
  <head>
    <script type="text/javascript"
      src="https://maps.googleapis.com/maps/api/js?key=API_KEY">
    </script>
\end{verbatim}

\item Initialize \\
Setelah melakukan load javascript, diperlukan pemanggilan fungsi initialize. Di
dalam fungsi tersebut dapat ditambahkan beberapa variabel yang dibutuhkan.
\begin{verbatim}
function initialize() {}
\end{verbatim}
Untuk inisialisasi peta, diperlukan variabel \textit{map options}
\begin{verbatim}
var mapOptions = {};
\end{verbatim}
Selanjutnya diperlukan koordinat pusat peta yang akan ditampilkan, sedangkan
zoom menunjukkan level zoom yang ingin ditampilkan
\begin{verbatim}
center: new google.maps.LatLng(-34.397, 150.644),
zoom: 8
\end{verbatim}

\item Map Object \\
objek peta perlu dibuat dengan cara melakukan inisialisasi kelas
google.maps.Map. Pada contoh, peta diletakkan pada <div> yang memiliki id
map-canvas.
\begin{verbatim}
var map = new google.maps.Map(document.getElementById("map-canvas"),
    mapOptions);
\end{verbatim}

\item Loading the Map \\
Google Maps API menyediakan fungsi untuk memuat peta. Pada potongan kode
di bawah, fungsi \textit{listener} akan memanggil fungsi \textit{initialize}
ketika halaman dimuat.
\begin{verbatim}
google.maps.event.addDomListener(window, 'load', initialize);
\end{verbatim}
\end{itemize}
Berikut ini adalah penjelasan kelas dan fungsi yang digunakan:
\begin{enumerate}
  \item google.maps.Map class\\
  Membuat peta baru pada halaman html.\\
  Konstruktor:
  \begin{itemize}
    \item mapDiv:Node\\
    node yang digunakan untuk membuat peta.
    
    \item opts?:MapOptions\\
    Opsi dari \textit{map} yang akan dibuat. 
  \end{itemize}
  
  \item google.maps.LatLng class\\
  Membuat objek Latlng yang merepresentasikan titik geografis.\\
  Konstruktor:
  \begin{itemize}
    \item lat:number\\
    \textit{Latitude} dalam derajat.
    
    \item lng:number\\
    \textit{Longitude} dalam derajat.
    
    \item noWrap?:boolean\\
    \textit{Latitude} ditentukan dalam rentang derajat -90 hingga 90 dan
    \textit{longitude} ditentukan dalam rentang derajat -180 hingga 180. Nilai
    \textit{true} pada boolean noWrap untuk mengaktifkan nilai di luar
    batas tersebut.
  \end{itemize}
  
  \item google.maps.event.addDomListener(instance:Object, eventName:string,
  handler:Function)\\
  Menambahkan fungsi \textit{listener}\\
  Parameter:
  \begin{itemize}
    \item instance:Object\\
    Objek yang ditambahkan \textit{listener}.
    
    \item eventName:string\\
    Nama \textit{Event}.
    
    \item handler:Function\\
    Fungsi yang dipanggil ketika \textit{event} terjadi.
  \end{itemize}
  Return:\\
  MapsEventListener
\end{enumerate}

\subsubsection{Menggambar pada Peta}
Peta pada Google Maps API dapat ditambahkan objek seperti titik, garis, area,
atau objek lainnya. objek tersebut dinamakan \textit{overlay}. Terdapat beberapa
jenis \textit{overlay} yang dapat ditambahkan pada peta yaitu \textit{marker}
dan \textit{polyline}. Berikut ini adalah penjelasan kelas dan fungsi yang
digunakan:
\begin{enumerate}
  \item google.maps.Marker class \\
  Membuat \textit{marker} pada peta dengan opsi tertentu.\\
  Konstruktor:
  \begin{itemize}
    \item opts?:MarkerOptions\\
    Opsi dari \textit{marker} yang dibuat.
  \end{itemize}
  
  \item google.maps.Polyline class\\
  Membuat \textit{polyline} pada peta dengan opsi tertentu.\\
  Konstruktor:
  \begin{itemize}
    \item opts?:PolylineOptions\\
    Opsi dari \textit{polyline} yang dibuat.
  \end{itemize}
  
  \item setMap(map:Map)\\
  Menyisipkan \textit{marker} atau \textit{polyline} pada peta tertentu.\\
  Parameter:
  \begin{itemize}
    \item map:Map\\
    Peta yang disisipkan \textit{marker} atau \textit{polyline}.
  \end{itemize}
  
  \item setIcon(icon:string|Icon|Symbol)\\
  Mengubah \textit{icon} pada \textit{marker}.\\
  Parameter:
  \begin{itemize}
    \item icon:string|Icon|Symbol\\
    \textit{Icon yang digunakan}.
  \end{itemize}
\end{enumerate}

Berikut ini adalah contoh penggunaan \textit{marker} dan \textit{polyline} pada
peta:
\begin{enumerate}
\item \textit{Marker} \\
Lokasi tunggal pada peta ditunjukkan oleh \textit{Marker}.
\begin{itemize}
  \item Menambahkan \textit{Marker} \\
  Untuk menampilkan \textit{marker} pada peta harus membuat objek
  google.maps.Marker. Berikut ini adalah atribut penting pada saat
  membuat objek \textit{marker}:
  \begin{enumerate}
    \item \textit{position} \\
    atribut \textit{position} diperlukan untuk mengatur letak \textit{marker}
    pada peta.
    
    \item \textit{map} \\
    atribut \textit{map} bersifat opsional, untuk menentukan marker
    tersebut akan diletakkan pada peta. Jika atribut \textit{map} tidak diatur,
    maka \textit{marker} akan tetap dibuat tetapi tidak akan ditampilkan pada
    peta.
  \end{enumerate}
  Berikut ini adalah contoh kode program untuk menambahkan \textit{marker} pada
  peta:
\begin{verbatim}
var myLatlng = new google.maps.LatLng(-25.363882,131.044922);
	var mapOptions = {
	  zoom: 4,
	  center: myLatlng
	}
	var map = new google.maps.Map(document.getElementById
	("map-canvas"), mapOptions);
	
	// To add the marker to the map, use the 'map' property
	var marker = new google.maps.Marker({
	    position: myLatlng,
	    map: map,
	    title:"Hello World!"
	});
\end{verbatim}
  Pada contoh, objek google.maps.Marker yang dibuat disimpan pada variabel
  \textit{marker}, terdapat atribut \textit{position} menggunakan variabel
  \textit{myLatlng} yang berisi koordinat (-25.363882,131.044922), atribut map
  menunjukkan bahwa \textit{marker} akan ditampilkan pada objek map yang tersimpan pada variabel
  \textit{map}, dan atribut yang menunjukkan judul \textit{marker}. 
  
  \item Mengubah \textit{icon marker}\\
  Untuk mengubah \textit{icon}, diperlukan pengaturan pada konstruktor
  \textit{marker} tersebut. Pada contoh, \textit{icon marker} diubah
  menjadi beachflag.png.
\begin{verbatim}
  var image = 'images/beachflag.png';
  var myLatLng = new google.maps.LatLng(-33.890542, 151.274856);
  var beachMarker = new google.maps.Marker({
      position: myLatLng,
      map: map,
      icon: image
  });
\end{verbatim}
Selain pengaturan pada kontruktor, pengubahan \textit{icon} juga dapat dilakukan
dengan cara memanggil fungsi setIcon()
\begin{verbatim}
	beachMarkers.setIcon('images/beachflag.png');
\end{verbatim}

  \item Menghapus \textit{Marker} pada peta\\
  Untuk menghapus \textit{marker} pada peta, hanya diperlukan pemanggilan
  fungsi setMap() dan mengisi parameter fungsi tersebut dengan \textit{null}.
  Contoh:
\begin{verbatim}
marker.setMap(null);
\end{verbatim}
  Pada contoh di atas hanya menghilangkan \textit{marker} dari peta dan tidak
  menghapus objek \textit{marker}.
  
  \item Animasi \textit{Marker} \\
  Menambahkan animasi pada \textit{marker}, hanya memerlukan pengaturan atribut
  pada konstruktor google.maps.Marker. Contoh:
\begin{verbatim}
  var marker = new google.maps.Marker({
	    position: myLatlng,
	    map: map,
	    animation: google.maps.Animation.BOUNCE,
	    title:"Hello World!"
	});
\end{verbatim}
  Pada contoh, menambahkan animasi \textit{bounce} pada marker sehingga
  \textit{marker} bergerak melompat-lompat pada peta. 
  
  \item Mengubah Ikon \\
  Gambar \textit{marker} pada peta dapat diubah sesuai keinginan, hanya
  memerlukan pengaturan atribut pada konstruktor google.maps.Marker. Contoh:
\begin{verbatim}
  var image = 'images/beachflag.png';
  var myLatLng = new google.maps.LatLng(-33.890542, 151.274856);
  var beachMarker = new google.maps.Marker({
      position: myLatLng,
      map: map,
      icon: image
  });
\end{verbatim}
  Pada contoh, ikon \textit{marker} akan ditampilkan menggunakan \textit{file}
  gambar beachflag.png
  
  \item \textit{Draggable} \\
  Draggable memungkinkan pengguna untuk menyeret marker ke lokasi yang berbeda,
  hanya memerlukan pengaturan atribut pada konstruktor google.maps.Marker. Contoh:
\begin{verbatim}
  var marker = new google.maps.Marker({
	    position: myLatlng,
	    map: map,
	    draggable: true,
	    title:"Hello World!"
	});
\end{verbatim}
\end{itemize}
\item \textit{Polyline} \\
Objek \textit{polyline} adalah serangkaian garis pada peta, \textit{polyline}
berguna untuk menunjukkan dari satu titik ke titik lain. \textit{Polyline}
memiliki atribut yang dapat diubah sesuai kebutuhan seperti warna,
\textit{opacity}, dan \textit{weight}. Berikut ini penjelasan dari
beberapa atribut tersebut:
\begin{itemize}
  \item \textit{strokeColor} \\
  Atribut \textit{strokeColor} menentukan warna dalam format
  heksadesimal, contoh \\ "\#FFFFFF''.
  
  \item \textit{strokeOpacity} \\
  Atribut \textit{strokeOpacity} menentukan \textit{opacity} dalam nilai antara
  0.0 dan 1.0.
  
  \item \textit{strokeWeight} \\
  Atribut \textit{strokeWeight} menentukan lebar garis dalam piksel.
\end{itemize}
Berikut ini adalah contoh potongan kode program untuk menampilkan
\textit{polyline} pada peta:
\begin{verbatim}
var flightPlanCoordinates = [
    new google.maps.LatLng(37.772323, -122.214897),
    new google.maps.LatLng(21.291982, -157.821856),
    new google.maps.LatLng(-18.142599, 178.431),
    new google.maps.LatLng(-27.46758, 153.027892)
  ];
  var flightPath = new google.maps.Polyline({
    path: flightPlanCoordinates,
    strokeColor: '#FF0000',
    strokeOpacity: 1.0,
    strokeWeight: 2
  });

  flightPath.setMap(map);
\end{verbatim}
Pada contoh, akan menampilkan polyline pada peta yang akan menghubungkan setiap 
koordinat yang terdapat pada variabel \textit{flightPlanCoordinates}.
\textit{Polyline} yang ditampilkan pada peta dapat dilihat pada Gambar \ref{fig:polyline}.
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{Gambar/polyline}
\caption[Polyline pada Peta]{Polyline pada Peta}
\label{fig:polyline}
\end{figure}
\end{enumerate}

\subsubsection{\textit{Geometry Library}}
Gambar pada Google Maps adalah dua dimensi, sedangkan bumi adalah tiga dimensi
yang menyerupai bentuk bola. Hal ini tentu akan berbeda ketika mengukur suatu
jarak dari satu titik ke titik lain, misalnya jarak terpendek antara dua titik 
pada bola bukanlah garis lurus, tetapi menyerupai lingkaran besar atau busur. 
Karena perbedaan tersebut, diperlukan \textit{spherical geometry} untuk
menghitung data geometris pada permukaan bumi seperti sudut, jarak, dan area 
yang berdasarkan garis lintang dan garis bujur. Google Maps JavaScript API 
menyediakan \textit{geometry library} yang memiliki fungsi utilitas tersebut,
fungsi utilitas tersebut dinamakan google.maps.geometry.spherical. Untuk
menghitung jarak antara dua titik dapat memanggil fungsi
computeDistanceBetween().
\begin{enumerate}
  \item google.maps.geometry.spherical namespace \\
  Fungsi utilitas untuk menghitung sudut, jarak, dan area. Secara
  \textit{default}, radius bumi yang digunakan adalah 6378137 meter.
  
  \item computeDistanceBetween(from:LatLng, to:LatLng, radius?:number) \\
  Menghitung jarak antara dua titik.\\
  Parameter:
  \begin{itemize}
    \item from:LatLng\\
    Koordinat titik pertama.
    
    \item to:LatLng\\
    Koordinat titik kedua.
    
    \item radius?:number\\
    Radius yang digunakan.
  \end{itemize}
\end{enumerate}
Berikut ini adalah contoh penggunaan fungsi computeDistanceBetween() untuk
menghitung jarak antara koordinat Kota Jakarta dan koordinat Kota Bandung:
\begin{verbatim}
var jakarta = new google.maps.LatLng(-6.1745,106.8227);
var bandung = new google.maps.LatLng(-6.9167,107.6000);

var distance = google.maps.geometry.spherical
.computeDistanceBetween(jakarta, bandung);
\end{verbatim}
setelah menggunakan fungsi computeDistanceBetween(), didapatkan jarak antara dua
titik koordinat tersebut adalah 119231.23264342443 meter atau lebih kurang
119,2 kilometer.
 
\subsubsection{\textit{Info Window}}
\textit{Info window} adalah kelas yang disediakan Google Maps untuk menampilkan
konten (biasanya berupa teks atau gambar) pada jendela \textit{popup}.
\textit{Info window} memiliki ujung yang melekat ke lokasi tertentu pada peta.
Biasanya \textit{info window} diletakkan pada \textit{marker} yang ada pada
peta, tetapi \textit{info window} juga dapat diletakkan pada koordinat peta
tertentu. Berikut ini adalah contoh potongan kode program yang menampilkan
\textit{marker} beserta \textit{info window}:
\begin{verbatim}
  var contentString = 'Info Window';

  var infowindow = new google.maps.InfoWindow({
      content: contentString
  });

  var marker = new google.maps.Marker({
      position: myLatlng,
      map: map,
      title: 'Uluru (Ayers Rock)'
  });
  google.maps.event.addListener(marker, 'click', function() {
    infowindow.open(map,marker);
  });
\end{verbatim}
Pada contoh, terdapat variabel \textit{contentString} yang berisi teks yang akan
dimuat pada \textit{info window}. Selanjutnya, diperlukan variabel
\textit{infowindow} yang menginisialisasi \textit{info window}, variabel
\textit{marker} yang menginisialisasi \textit{marker}, dan \textit{listener}
yang memanggil fungsi \textit{open} ketika \textit{marker} tersebut diklik.
Berikut ini adalah penjelasan dari kelas dan fungsi yang digunakan:
\begin{enumerate}
\item google.maps.InfoWindow class\\
  Membuat \textit{overlay} yang berbentuk seperti gelembung dan memuat konten
  seperti teks atau gambar.\\
  Konstruktor:
  \begin{itemize}
    \item opts?:InfoWindowOptions\\
    Opsi dari \textit{info window} yang dibuat.
  \end{itemize}
  
\item open(map?:Map|StreetViewPanorama, anchor?:MVCObject)\\
  Membuka info window pada peta.\\
  Parameter
  \begin{itemize}
    \item map?:Map|StreetViewPanorama\\
    Membuka \textit{info window} pada peta yang diberikan.
    
    \item anchor?:MVCObject\\
    Objek yang berasosiasi dengan \textit{info window}, contoh: \textit{marker}.
  \end{itemize}
\end{enumerate}
\textit{Info Window} yang ditampilkan pada peta dapat dilihat pada Gambar
\ref{fig:infowindow}.
\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{Gambar/infowindow}
\caption[Info Window pada Peta]{Info Window pada Peta}
\label{fig:infowindow}
\end{figure}


\section{Graf}
Graf adalah himpunan objek yang terdiri dari node (simpul) dan edge (sisi), graf 
digambarkan sebagai node yang dihubungkan oleh edge \footnotemark[2]. Terdapat
berbagai macam jenis graf, tetapi pada subbab ini hanya dibahas beberapa jenis
graf seperti graf tidak berarah, graf berarah, dan graf berbobot. Contoh graf dapat
dilihat pada Gambar \ref{fig:graph}.
\footnotetext[2]{http://web.cecs.pdx.edu/sheard/course/Cs163/Doc/Graphs.html}

\subsection{Graf Tidak Berarah}
Graf tidak berarah adalah graf yang tidak memiliki arah pada setiap edgenya,
sehingga setiap node tidak memiliki urutan. Graf tidak berarah digambarkan dengan garis lurus
antara node. Contoh graf berarah dapat dilihat pada Gambar
\ref{fig:graph}.
\begin{figure}[h]
\centering
\includegraphics[scale=1]{Gambar/graph}
\caption[Contoh Graf]{Contoh Graf}
\label{fig:graph}
\end{figure}
Berdasarkan contoh pada Gambar \ref{fig:graph}  didapatkan informasi tipe dari
node adalah bilangan bulat. \\
Himpunan node = $\left\{ 1,2,3,4,5,6 \right\}$ \\
Himpunan edge = $\left\{ (6,4),(4,5),(4,3),(3,2),(5,2),(2,1),(5,1) \right\}$

\subsection{Graf Berarah}
Graf berarah memiliki arah pada setiap edgenya. Pada graf berarah, edge biasanya
digambarkan dengan panah sesuai arahnya. Contoh graf berarah dapat dilihat pada
Gambar \ref{fig:direc_graph}.
\begin{figure}[h]
\centering
\includegraphics[scale=1]{Gambar/direc_graph}
\caption[Contoh Graf Berarah]{Contoh Graf Berarah}
\label{fig:direc_graph}
\end{figure}
Berdasarkan contoh pada Gambar \ref{fig:direc_graph}  didapatkan informasi tipe
dari node adalah huruf kapital. \\
Himpunan node = $\left\{ A, B, C, D, E \right\}$\\ 
Himpunan edge = $\left\{ (A, B), (B, C), (D, C), (B, D), (D, B), (E, D), (B,E) \right\}$

\subsection{Graf Berbobot}
Graf berbobot adalah graf yang memiliki nilai pada setiap edgenya. Nilai
tersebut dapat berupa bilangan bulat ataupun bilangan pecahan desimal. Nilai
tersebut dapat digunakan untuk menyimpan jarak dari suatu node ke node lain.
Contoh graf berbobot dapat dilihat pada Gambar \ref{fig:weight_graph}.
\begin{figure}[h]
\centering
\includegraphics[scale=1]{Gambar/weight_graph}
\caption[Contoh Graf Berbobot]{Contoh Graf Berbobot}
\label{fig:weight_graph}
\end{figure}
Berdasarkan contoh pada Gambar \ref{fig:weight_graph}  didapatkan informasi tipe
dari node adalah bilangan bulat dan tipe dari bobot adalah bilangan bulat. \\
Himpunan node = $\left\{ 1,2,3,4,5 \right\}$ \\ 
Himpunan edge = $\left\{ (1,4,5) ,(4,5,58) ,(3,5,34) ,(2,4,5) ,(2,5,4) ,(3,2,14)
,(1,2,2) \right\}$

\subsection{Representasi Graf}
Terdapat dua cara untuk merepresentasikan graf yaitu dengan \textit{adjacency
list} dan \textit{adjacency matrix} \cite{Cormen:2001}. Keduanya dapat
merepresentasikan graf berarah ataupun graf tidak berarah. \textit{Adjacency list} merepresentasikan
graf ke dalam bentuk array, sedangkan \textit{adjacency matrix}
merepresentasikan graf ke dalam bentuk matriks.
\begin{itemize}
  \item \textit{Adjacency List}\\
  \textit{Adjacency List} merupakan representasi graf ke dalam bentuk array,
  panjang array sesuai dengan jumlah node pada graf. Setiap index pada array
  mengacu pada setiap node graf, setiap index array tersebut memiliki list yang
  merepresentasikan hubungan dengan node-node lainnya. Contoh representasi graf
  tidak berarah dalam bentuk \textit{adjacency list} dapat dilihat pada Gambar 
  \ref{fig:adjlist_undirec} dan representasi graf berarah
  dalam bentuk \textit{adjacency list} dapat dilihat pada Gambar
  \ref{fig:adjlist_direc}.
  
\begin{figure}[h]
\centering
\includegraphics[scale=1]{Gambar/adjlist_undirec}
\caption[Contoh Adjacency List]{Contoh Adjacency List (Graf Tidak Berarah)}
\label{fig:adjlist_undirec}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=1]{Gambar/adjlist_direc}
\caption[Contoh Adjacency List]{Contoh Adjacency List (Graf Berarah)}
\label{fig:adjlist_direc}
\end{figure}
  
  \item \textit{Adjacency Matrix}\\
  \textit{Adjacency Matrix} merupakan representasi graf ke dalam bentuk matriks
  nxn, pada matriks tersebut menyatakan hubungan antar node atau pada graf.
  Nilai n pada matriks nxn sesuai dengan jumlah node pada graf. Nilai 1 pada
  matriks menandakan terdapat hubungan pada node dan sebaliknya jika bernilai
  0. Contoh representasi graf tidak berarah dalam bentuk \textit{adjacency
  matrix} dapat dilihat pada Gambar \ref{fig:adjmat_undirec} dan representasi
  graf berarah dalam bentuk \textit{adjacency matrix} dapat dilihat pada Gambar
  \ref{fig:adjmat_direc}.
  
\begin{figure}[h]
\centering
\includegraphics[scale=0.9]{Gambar/adjmat_undirec}
\caption[Contoh Adjacency Matrix]{Contoh Adjacency Matrix (Graf Tidak Berarah)}
\label{fig:adjmat_undirec}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[scale=0.9]{Gambar/adjmat_direc}
\caption[Contoh Adjacency Matrix]{Contoh Adjacency Matrix (Graf Berarah)}
\label{fig:adjmat_direc}
\end{figure}
\end{itemize}

\section{Algoritma Dijkstra}
Algoritma dijkstra adalah algoritma yang dapat mencari jalur terpendek pada graf
berarah G=(V,E) untuk kasus pada setiap sisinya bernilai tidak
negatif \cite{Cormen:2001}. V adalah himpunan tidak kosong dari node dan E
adalah himpunan sisi yang menghubungkan sepasang node. Algoritma ini menggunakan
prinsip greedy, prinsip greedy pada algoritma dijkstra adalah memilih sisi yang
memiliki bobot paling kecil dan memasukannya dalam himpunan solusi. Berikut ini adalah
\textit{pseudocode} dari algoritma dijkstra:
\begin{algorithm}{}\label{dijkstra}
\caption{$Dijkstra$}
\begin{algorithmic}
\State $dist[s] \leftarrow 0$
\ForAll{$v \in V$}
\State $dist[v] \leftarrow \infty$ 
\EndFor
\State $S \leftarrow \emptyset$
\State $Q \leftarrow V$
\While{$Q \neq \emptyset$} 
\State $u \leftarrow  minDistance(Q,dist)$
\State $S \leftarrow u$
\ForAll{$v \in neighbors[u]$}
\If{$dist[v] > dist[u] + w(u,  v)$}
\State $d[v] \leftarrow d[u] + w(u,  v)$
\EndIf
\EndFor
\EndWhile \\
\Return dist
\end{algorithmic}
\end{algorithm}
Langkah-langkah yang dilakukan adalah:
\begin{enumerate}
  \item Inisialisasi node asal dengan nilai 0, dan inisialisasi seluruh node
  lainnya dengan nilai tak terhingga.
  
  \item S adalah himpunan node yang sudah dikunjungi, untuk awal inisialisasi
  dengan himpunan kosong.
  
  \item Q adalah struktur data \textit{queue}, inisialisasi dengan seluruh node.
  
  \item Keluarkan node yang memiliki jarak paling kecil dari dalam
  \textit{queue} dan tambahkan node tersebut ke dalam himpunan node yang sudah dikunjungi.
  
  \item Lakukan pengulangan untuk seluruh node tetangga dan periksa jika jarak
  terpendek lain ditemukan tandai node tersebut.
  
  \item Ulangi langkah 4 dan 5 hingga seluruh node di dalam \textit{queue}
  habis.
\end{enumerate}

\section{Haversine \textit{Formula}}
Haversine \textit{formula} adalah persamaan yang dapat memberikan jarak antara
dua titik berdasarkan \textit{latitude} atau garis lintang dan
\textit{longitude} atau garis bujur \cite{haversine}. Haversine
\textit{formula} dinyatakan dalam persamaan berikut ini:
\\
\[d=2r\sin^{-1}(\sqrt{\sin^2(\frac{\phi_2-\phi_1}{2})+\cos(\phi_1)\cos(\phi_2)\sin^2(\frac{\psi_2-\psi_1}{2})})\]
dimana:
\begin{itemize}
  \item d : jarak antara dua buah titik (dalam satuan km)
  
  \item r : radius bumi (6371 km)
   
  \item $\phi_1, \phi_2$ : \textit{latitude} dari titik 1 dan \textit{latitude}
  dari titik 2
  
  \item $\psi_1, \psi_2$ : \textit{longitude} dari titik 1 dan
  \textit{longitude} dari titik 2
\end{itemize}
